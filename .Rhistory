months.forecast
forecasts
forecasts <-
plot(naive(ASX.dc, h = 5), ylab="New orders index")
forecasts <-
plot(naive(ASX.dc), ylab="New orders index")
forecasts <- forecast(ASX.dc, method="naive", h = 5)
plot(forecasts, ylab="New orders index")
forecasts
# Forecasting using Naive Method for 5 months
forecasts <- forecast(ASX.dc, method="naive", h = 5)
plot(forecasts, ylab="New orders index")
# 5 months forecasted values with 80% and 95% Confidence Interval
forecasts
plot(seasadj(ASX.dc),
main='Ordinaries Price Index by Month - Seasonally Adjusted
Australian Share Market, 2003-2017',
ylab='Price Index',xlab='Years')
points(y=seasadj(ASX.dc),x=time(seasadj(ASX.dc)), pch=as.vector(season(seasadj(ASX.dc))))
# Forecasting using Naive Method for 5 months
forecasts <- forecast(ASX.dc, method="naive", h = 5)
plot(forecasts,
main='Ordinaries Price Index by Month - Seasonally Adjusted
Australian Share Market, 2003-2017',
ylab='Price Index',xlab='Years')
# Forecasting using Naive Method for 5 months
forecasts <- forecast(ASX.dc, method="naive", h = 5)
plot(forecasts,
main='Ordinaries Price Index by Month - Forecast using STL
Australian Share Market, 2003-2017',
ylab='Price Index',xlab='Years')
4 * 80 + 5 * 70
letters
letters[1:3]
rep(letters[1:3])
rep(letters[1:3],3)
rep(letters[1:3],10)
rep(letters[1:3],each=10)
factor(rep(letters[1:3],each=10))
rnorm(30)
df = (gp = factor(rep(letters[1:3],each=10)),
y = rnorm(30))
df = data.frame(gp = factor(rep(letters[1:3],each=10)),
y = rnorm(30))
df
ds <- plyr::ddply(df, "gp", plyr::summarise, mean = mean(y), sd = sd(y))
ddply
ds
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3)
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3)
require(tidyverse)
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3)
ggplot(df) +
geom_point(aes(gp, y)) +
geom_point(data = ds, aes(gp, mean), colour = 'red', size = 3)
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3) +
geom_errorbar(
data = ds,
aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
colour = 'red',
width = 0.4
)
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3) +
geom_errorbar(
data = ds,
aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
colour = 'red'
)
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3) +
geom_errorbar(
data = ds,
aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
colour = 'red',
width = 0.4
)
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3) +
geom_errorbar(
data = ds,
aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
colour = 'red',
width = 0.2
)
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3) +
geom_errorbar(
data = ds,
aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
colour = 'pint',
width = 0.2
)
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3) +
geom_errorbar(
data = ds,
aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
colour = 'pink',
width = 0.2
)
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3) +
geom_errorbar(
data = ds,
aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
colour = 'red',
width = 0.2
)
ggplot() +
geom_errorbar(
data = ds,
aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
colour = 'red',
width = 0.2
)
ggplot() +
geom_errorbar(
data = ds,
aes(gp, mean),
colour = 'red',
width = 0.2
)
mean
gp
ds
ggplot() +geom_abline(intercept = 0, slope = 1)
ggplot() +geom_abline(intercept = 0, slope = 1) + +geom_abline(intercept = 0, slope = -1)
ggplot() +geom_abline(intercept = 0, slope = 1) + geom_abline(intercept = 0, slope = -1)
ggplot() +geom_abline(intercept = 0, slope = 1) + geom_abline(intercept = 0, slope = -5)
ggplot() +geom_abline(intercept = 0, slope = 1) + geom_abline(intercept = 0, slope = -1)
p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
p + geom_vline(xintercept = 5)
p + geom_abline(slope = 0, intercept = 5)
p + geom_abline(slope = 0, intercept = 5)
p + geom_vline(xintercept = 5)
p + geom_abline(intercept = 5)
p + geom_vline(xintercept = 1:5)
p + geom_hline(yintercept = 20)
p + geom_hline(yintercept = mean(mpg))
mean(mtcars$mpg
mean(mtcars$mpg)
mean(mtcars$mpg)
p + geom_hline(yintercept = mean(mtcars$mpg))
p + geom_hline(yintercept = mean(mtcars$mpg)) + geom_vline(xintercept = mean(mtcars$mpg))
p + geom_hline(yintercept = mean(mtcars$mpg)) + geom_vline(xintercept = mean(mtcars$wt))
coef(lm(mpg ~ wt, data = mtcars))
lm(mpg ~ wt, data = mtcars)
p + geom_abline(intercept = 37, slope = -5)
coef(lm(mpg ~ wt, data = mtcars))[1]
coef(lm(mpg ~ wt, data = mtcars))[2]
p + geom_abline(intercept = coef(lm(mpg ~ wt, data = mtcars))[1], slope = coef(lm(mpg ~ wt, data = mtcars))[2])
p + geom_smooth(method = "lm", se = FALSE)
p <- ggplot(mtcars, aes(mpg, wt)) +
geom_point() +
facet_wrap(~ cyl)
ggplot(mtcars, aes(mpg, wt)) +
geom_point() +
facet_wrap(~ cyl)
mean_wt <- data.frame(cyl = c(4, 6, 8), wt = c(2.28, 3.11, 4.00))
mean_wt
p + geom_hline(aes(yintercept = wt), mean_wt)
p + geom_hline(yintercept = wt, mean_wt)
mean_wt <- data.frame(cyl = c(4, 6, 8), wt = c(2.28, 3.11, 4.00))
p + geom_hline(yintercept = wt, mean_wt)
p + geom_hline(mean_wt,yintercept = wt)
p + geom_hline(yintercept = mean_wt$wt)
p + geom_hline(mean_wt,aes(yintercept = wt))
p + geom_hline(mean_wt,aes(yintercept = wt))
p + geom_hline(aes(yintercept = wt),mean_wt)
ggplot(mtcars, aes(mpg, wt, colour = wt)) +
geom_point() +
geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
facet_wrap(~ cyl)
require(graphics)
pairs(mtcars, main = "mtcars data")
coplot(mpg ~ disp | as.factor(cyl), data = mtcars,
panel = panel.smooth, rows = 1)
ggplot(mtcars, aes(mpg, wt, colour = wt)) +
geom_point() +
geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
facet_wrap(~ cyl)
q()
ggplot(mtcars, aes(mpg, wt, colour = wt)) +
geom_point() +
geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
facet_wrap(~ cyl)
require(tidyverse)
ggplot(mtcars, aes(mpg, wt, colour = wt)) +
geom_point() +
geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
facet_wrap(~ cyl)
p + geom_abline(intercept = coef(lm(mpg ~ wt, data = mtcars))[1], slope = coef(lm(mpg ~ wt, data = mtcars))[2])
## Load Libraries
require(tidyverse)
## Create a new ggplot
df = data.frame(gp = factor(rep(letters[1:3],each=10)),
y = rnorm(30))
# ddply - Split data frame, apply function, and return results in a data frame
ds <- plyr::ddply(df, "gp", plyr::summarise, mean = mean(y), sd = sd(y))
ggplot(df, aes(gp, y)) +
geom_point() +
geom_point(data = ds, aes(y = mean), colour = 'red', size = 3) +
geom_errorbar(
data = ds,
aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
colour = 'red',
width = 0.2
)
## Abline
p <- ggplot(mtcars, aes(wt, mpg)) + geom_point()
# Fixed values
p + geom_vline(xintercept = 5)
p + geom_vline(xintercept = 1:5)
p + geom_hline(yintercept = mean(mtcars$mpg)) + geom_vline(xintercept = mean(mtcars$wt))
# Calculate slope and intercept of line of best fit
coef(lm(mpg ~ wt, data = mtcars))[2]
#> (Intercept)          wt
#>   37.285126   -5.344472
p + geom_abline(intercept = coef(lm(mpg ~ wt, data = mtcars))[1], slope = coef(lm(mpg ~ wt, data = mtcars))[2])
# Easy to do with geom smooth
p + geom_smooth(method = "lm", se = FALSE)
# To show different lines in different facets, use aesthetics
p <- ggplot(mtcars, aes(mpg, wt)) +
geom_point() +
facet_wrap(~ cyl)
mean_wt <- data.frame(cyl = c(4, 6, 8), wt = c(2.28, 3.11, 4.00))
p + geom_hline(aes(yintercept = wt),mean_wt)
# You can also control other aesthetics
ggplot(mtcars, aes(mpg, wt, colour = wt)) +
geom_point() +
geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
facet_wrap(~ cyl)
p + geom_hline(aes(yintercept = wt),mean_wt)
15 * (95/6)
15 * (5/6)
15 * (5/6) + 15 * (5/6) - 12 * (5/6) * (5/6) -10
15 * (5/6) + 10 * (5/6) - 12 * (5/6) * (5/6) - 10
10 * (5/6) + 15 * (5/6) - 12 * (5/6) * (5/6) - 10
15 * (5/6) + 10 * (5/6) - 12 * (5/6) * (5/6) - 10
## Load Libraries
require(TSA)
require(forecast)
require(ggplot2)
require(dLagM) # Distributed lag models library
## Set Working Directory
setwd("C:/Users/rahul/Google Drive/RMIT/Semester 2/Forecasting/Assignment 2")
## Import File
# Data About monthly average horizontal solar radiation and the monthly precipitation
# January 1960 and December 2014
Radiation = read.csv('data1.csv')
head(Radiation)
# Conversion to time series Object
Radiation.ts = ts(Radiation,start = 1960,frequency = 12)
Solar.Radiation = ts(Radiation$solar,start = 1960,frequency = 12)
PPT.Radiation = ts(Radiation$ppt,start = 1960,frequency = 12)
##------------
## Plot Graphs
##------------
## Average Solar Radiation
par(mfrow=c(1,1))
plot(Solar.Radiation)
points(x=time(Solar.Radiation),y=Solar.Radiation,pch=as.vector(season(Solar.Radiation)))
# No trend, obvious seasonality, no changing mean but changing variance, Intervention present
par(mfrow=c(1,2))
acf(Solar.Radiation, lag.max = 48, main = "Sample ACF for Average Solar Radiation")
pacf(Solar.Radiation, lag.max = 48, main = "Sample PACF for Average Solar Radiation")
# Indication of Tread; Series is stationary
## Check for stationary
adf.test(Solar.Radiation)
## ---------------------------------------
## Forecasting for Average Solar Radiation
##----------------------------------------
0.1802848 * 0.8153212
## ---------------------------------------
## Forecasting for Average Solar Radiation
##----------------------------------------
156.5277 (1 - 0.1802848)
## ---------------------------------------
## Forecasting for Average Solar Radiation
##----------------------------------------
156.5277 * (1 - 0.1802848)
## Load Libraries
require(TSA)
require(forecast)
require(ggplot2)
require(dLagM) # Distributed lag models library
## Set Working Directory
setwd("C:/Users/rahul/Google Drive/RMIT/Semester 2/Forecasting/Assignment 2")
## Import File
# Data About monthly average horizontal solar radiation and the monthly precipitation
# January 1960 and December 2014
Radiation = read.csv('data1.csv')
head(Radiation)
# Conversion to time series Object
Radiation.ts = ts(Radiation,start = 1960,frequency = 12)
Solar.Radiation = ts(Radiation$solar,start = 1960,frequency = 12)
PPT.Radiation = ts(Radiation$ppt,start = 1960,frequency = 12)
##------------
## Plot Graphs
##------------
## Average Solar Radiation
par(mfrow=c(1,1))
plot(Solar.Radiation)
points(x=time(Solar.Radiation),y=Solar.Radiation,pch=as.vector(season(Solar.Radiation)))
# No trend, obvious seasonality, no changing mean but changing variance, Intervention present
par(mfrow=c(1,2))
acf(Solar.Radiation, lag.max = 48, main = "Sample ACF for Average Solar Radiation")
pacf(Solar.Radiation, lag.max = 48, main = "Sample PACF for Average Solar Radiation")
# Indication of Tread; Series is stationary
## Check for stationary
adf.test(Solar.Radiation)
## ---------------------------------------
## Forecasting for Average Solar Radiation
##----------------------------------------
# Checking the correlation between Solar and precipitation
# Inverse correlation of 45%
cor(Solar.Radiation,PPT.Radiation)
## Distributed Lag Models
DLM.Q = finiteDLMauto(x = as.vector(Solar.Radiation) , y = as.vector(PPT.Radiation))
model1 = dlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation) , q = DLM.Q$q , show.summary = TRUE)
checkresiduals(model1$model$residuals)
VIF.model = vif(model1$model)
VIF.model1 > 10
# Model can have multi collinearity issue
## Polynomial Distributed Lags
model2 = polyDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)  , q = DLM.Q$q ,
k = 2, show.beta = FALSE , show.summary = TRUE)
## Koyck Transformation
model3 = koyckDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)  , show.summary = TRUE)
checkresiduals(model3$model$residuals)
# Serial correlation exists in the model but over model is significant at p < 0.01 and Adjusted R-squared: 0.6606
VIF.model3 = vif(model3$model)
VIF.model3 > 10
# Model is not suffering from Multi collinearity
## Autoregressive Distributed Lag Model
model.11 = ardlDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)
, p = 1 , q = 1 , show.summary = TRUE)$model
model.22 = ardlDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)
, p = 2 , q = 2 , show.summary = TRUE)$model
model.33 = ardlDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)
, p = 3 , q = 3 , show.summary = TRUE)$model
models.AIC = AIC(model.11,model.22,model.33)
models.BIC = BIC(model.11,model.22,model.33)
sortScore(models.AIC, score = 'aic')
sortScore(models.BIC, score = 'bic')
checkresiduals(model.33$residuals)
bgtest(model.33)
model.33 = ardlDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)
, p = 3 , q = 3 , show.summary = TRUE)
# Get predictor series values for forecast
Precipitate = read.csv('data.x.csv')
predictor.Precipitate = as.vector(Precipitate$x)
predictor.length = length(predictor.Precipitate)
forecasts.dlm = dlmForecast(model = model1 , x = predictor.Precipitate , h = predictor.length)$forecasts
predictor.dlm = ts(c(Solar.Radiation, forecasts.dlm),start = 1960,frequency = 12)
plot(predictor.dlm,xaxt="n" )
lines(PPT.Radiation,col="Red")
legend("topleft",lty=1, pch = 1, text.width = 6, col=c("black","red"), c("Fits and Forecasts", "Appropriations"))
forecasts.polydlm = polyDlmForecast(model = model2 , x = predictor.Precipitate , h = predictor.length)$forecasts
predictor.polydlm = ts(c(Solar.Radiation, forecasts.polydlm),start = 1960,frequency = 12)
forecasts.koyckdlm = koyckDlmForecast(model = model3 , x = predictor.Precipitate , h = predictor.length)$forecasts
predictor.koyckdlm = ts(c(Solar.Radiation, forecasts.koyckdlm),start = 1960,frequency = 12)
forecasts.ardldlm = ardlDlmForecast(model = model.33 , x = predictor.Precipitate , h = predictor.length)$forecasts
predictor.ardldlm = ts(c(Solar.Radiation, forecasts.koyckdlm),start = 1960,frequency = 12)
plot(ts(predictor.ardldlm),type="l",xaxt="n")
par(mfrow=c(1,1))
plot(ts(predictor.ardldlm),type="l",xaxt="n")
plot(predictor.ardldlm,type="l",xaxt="n")
predictor.polydlm
plot(predictor.ardldlm,type="l")
lines(predictor.dlm,col="Blue",type="l")
lines(predictor.polydlm,col="Green",type="l")
lines(predictor.koyckdlm,col="violet",type="l")
lines(PPT.Radiation,col="Red",type="l")
legend("topleft",lty=1, text.width = 16, col=c("black","blue","green",'violet', "red"),
c("ARDL","DLM", "Polynomial", "Koyck", "Appropriations"))
plot(predictor.ardldlm,type="l")
lines(forecasts.polydlm,col="Blue",type="l")
lines(forecasts.polydlm,col="Blue",type="l")
lines(forecasts.koyckdlm,col="Green",type="l")
par(mfrow=c(1,1))
{
plot(predictor.ardldlm,type="l")
lines(predictor.dlm,col="Blue",type="l")
lines(predictor.polydlm,col="Green",type="l")
lines(predictor.koyckdlm,col="violet",type="l")
lines(PPT.Radiation,col="Red",type="l")
legend("topleft",lty=1, text.width = 16, col=c("black","blue","green",'violet', "red"),
c("ARDL","DLM", "Polynomial", "Koyck", "Appropriations"))
}
# Data About monthly average horizontal solar radiation and the monthly precipitation
# January 1960 and December 2014
Radiation = read.csv('data1.csv')
head(Radiation)
# Conversion to time series Object
Radiation.ts = ts(Radiation,start = 1960,frequency = 12)
Solar.Radiation = ts(Radiation$solar,start = 1960,frequency = 12)
PPT.Radiation = ts(Radiation$ppt,start = 1960,frequency = 12)
## Average Solar Radiation
par(mfrow=c(1,1))
plot(Solar.Radiation)
points(x=time(Solar.Radiation),y=Solar.Radiation,pch=as.vector(season(Solar.Radiation)))
par(mfrow=c(1,2))
acf(Solar.Radiation, lag.max = 48, main = "Sample ACF for Average Solar Radiation")
pacf(Solar.Radiation, lag.max = 48, main = "Sample PACF for Average Solar Radiation")
par(mfrow=c(1,2))
acf(Solar.Radiation, lag.max = 48, main = "Sample ACF for Average Solar Radiation")
pacf(Solar.Radiation, lag.max = 48, main = "Sample PACF for Average Solar Radiation")
## Check for stationary
adf.test(Solar.Radiation)
# Checking the correlation between Solar and precipitation
# Inverse correlation of 45%
cor(Solar.Radiation,PPT.Radiation)
DLM.Q = finiteDLMauto(x = as.vector(Solar.Radiation) , y = as.vector(PPT.Radiation))
model1 = dlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation) , q = DLM.Q$q , show.summary = TRUE)
VIF.model1 > 10
VIF.model = vif(model1$model)
VIF.model1 > 10
source('C:/Users/rahul/Google Drive/RMIT/Semester 2/Forecasting/Assignment 2/FC Assignment 2.R', echo=TRUE)
checkresiduals(model1$model$residuals)
qqnorm(model1$model$residuals)
shapiro.test(model1$model$residuals)
qqnorm(model1$model$residuals)
qqplot(model1$model$residuals)
qqplot(y=model1$model$residuals)
qqplot(x,y=model1$model$residuals)
qqplot(model1$model$residuals)
qqnorm(model1$model$residuals);qqline(model1$model$residuals)
qqnorm(model1$model$residuals);qqline(model1$model$residuals)
qqnorm(model1$model$residuals)
qqline(model1$model$residuals)
qqnorm(model1$model$residuals); qqline(model1$model$residuals)
shapiro.test(model1$model$residuals)
## Koyck Transformation
model3 = koyckDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)  , show.summary = TRUE)
checkresiduals(model3$model$residuals)
# Serial correlation exists in the model but over model is significant at p < 0.01 and Adjusted R-squared: 0.6606
VIF.model3 = vif(model3$model)
VIF.model3 > 10
vif(model3$model)
## Koyck Transformation
model3 = koyckDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)  , show.summary = TRUE)
dwtest(Y.t ~ Y.t_1 + X.t | Y.t_1 + X.t_1)
## generate regressor and dependent variable
x <- rep(c(-1,1), 50)
y1 <- 1 + x + err1
## perform Durbin-Watson test
dwtest(y1 ~ x)
## generate regressor and dependent variable
x <- rep(c(-1,1), 50)
y1 <- 1 + x + err1
err1 <- rnorm(100)
## generate regressor and dependent variable
x <- rep(c(-1,1), 50)
y1 <- 1 + x + err1
## perform Durbin-Watson test
dwtest(y1 ~ x)
lm(rnorm(1000)~jitter(1:1000))
source('C:/Users/rahul/Google Drive/Analytics/Scratch Pad/Scratch Pad.R', echo=TRUE)
x = lm(rnorm(1000)~jitter(1:1000))
summary(x)
x = lm(rnorm(1000)~jitter(1:1000))
summary(x)
model2 = polyDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)  , q = DLM.Q$q ,
k = 2, show.beta = FALSE , show.summary = TRUE)
DLM.Q$q
model2 = polyDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)  , q = DLM.Q$q ,
k = 2, show.beta = FALSE , show.summary = TRUE)
## Koyck Transformation
model3 = koyckDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)  , show.summary = TRUE)
checkresiduals(model3$model$residuals)
VIF.model3 = vif(model3$model)
VIF.model3 > 10
## Koyck Transformation
model3 = koyckDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)  , show.summary = TRUE)
model.11 = ardlDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)
, p = 1 , q = 1 , show.summary = TRUE)$model
model.22 = ardlDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)
, p = 2 , q = 2 , show.summary = TRUE)$model
model.33 = ardlDlm(x = as.vector(PPT.Radiation), y = as.vector(Solar.Radiation)
, p = 3 , q = 3 , show.summary = TRUE)$model
models.AIC = AIC(model.11,model.22,model.33)
models.BIC = BIC(model.11,model.22,model.33)
sortScore(models.AIC, score = 'aic')
sortScore(models.BIC, score = 'bic')
checkresiduals(model.33$residuals)
bgtest(model.33)
bgtest(model3)
bgtest(model2)
bgtest(model.33)
Box.test(model.33$residuals)
lung
dwtest(model.33$residuals)
bgtest(model.33)
Box.test(model.33$residuals)
Box.test(model.33$residuals)
qqnorm(model.33$residuals); qqline(model.33$residuals)
